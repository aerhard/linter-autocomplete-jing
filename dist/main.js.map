{"version":3,"file":"main.js","sources":["../src/autocomplete/util.ts","../src/autocomplete/xmlChar.ts","../src/autocomplete/getAttributeNameSuggestions.ts","../src/autocomplete/getAttributeValueSuggestions.ts","../src/autocomplete/getMarkupSuggestions.ts","../src/autocomplete/suggest.ts","../node_modules/sax/lib/sax.js","../src/util/generateRange.ts","../src/getParserConfig.ts","../src/util/logError.ts","../src/rules/validateRules.ts","../src/rules/getRulesFromAtomPackages.ts","../src/rules/RuleStore.ts","../src/util/notifications.ts","../src/validation/createLinterMessages.ts","../src/xmlService/client.ts","../node_modules/isexe/windows.js","../node_modules/isexe/mode.js","../node_modules/isexe/index.js","../node_modules/which/which.js","../node_modules/path-key/index.js","../node_modules/cross-spawn/lib/util/resolveCommand.js","../node_modules/cross-spawn/lib/util/escape.js","../node_modules/shebang-regex/index.js","../node_modules/cross-spawn/lib/util/readShebang.js","../node_modules/shebang-command/index.js","../node_modules/cross-spawn/lib/parse.js","../node_modules/cross-spawn/lib/enoent.js","../node_modules/cross-spawn/index.js","../src/xmlService/ServerProcessManager.ts","../src/xmlService/util.ts","../src/xmlService/XmlService.ts","../src/main.ts","../src/validation/validate.ts"],"sourcesContent":["import { Point, ScopeDescriptor, TextEditor } from 'atom'\n\nexport interface AutocompleteContext {\n  editor: TextEditor\n  bufferPosition: Point\n  scopeDescriptor: ScopeDescriptor\n  prefix: string\n  activatedManually: boolean\n}\n\nexport interface Suggestion {\n  snippet: string\n  displayText: string\n  type: 'attribute' | 'value' | 'tag'\n  rightLabel?: string\n  replacementPrefix: string\n  description?: string\n  retrigger?: boolean\n}\n\nconst precedingAttValueOrTagDelimiterRegex = /\"[^<]*?\"|'[^<]*?'|<\\/|<|>/g\n\n/**\n * Returns `true` if the first tag delimiter preceding the cursor in the current\n * XML document is a start tag start delimiter (\"<\") rather than an end tag\n * start delimiter (\"</\") or an end delimiter (\">\" / \"/>\").\n * Occurrences within attribute values are ignored.\n */\nexport const precedingTagDelimiterIsStartTagStartDelimiter = ({\n  editor,\n  bufferPosition,\n}: AutocompleteContext): boolean => {\n  let result = false\n\n  editor.backwardsScanInBufferRange(\n    precedingAttValueOrTagDelimiterRegex,\n    [bufferPosition, [0, 0]],\n    ({ matchText, stop }) => {\n      if (matchText.startsWith(\"'\") || matchText.startsWith('\"')) {\n        // matched attribute value: continue scanning\n        return\n      }\n\n      if (matchText === '<') {\n        result = true\n      }\n      stop()\n    }\n  )\n\n  return result\n}\n\nconst nextAttValueOrTagDelimiterRegex = /\"[^<]*?\"|'[^<]*?'|<|\\/>|>/g\n\n/**\n * Returns the position of the next tag end delimiter (\">\" or \"/>\") following\n * the cursor in the current XML document, skipping occurrences within attribute\n * values.\n * Returns null if there's no match or a tag start delimiter \"<\" is encountered.\n */\nexport const getNextTagEndDelimiterPosition = ({\n  editor,\n  bufferPosition,\n}: AutocompleteContext): Point | null => {\n  let position = null\n\n  editor.scanInBufferRange(\n    nextAttValueOrTagDelimiterRegex,\n    [bufferPosition, editor.getBuffer().getEndPosition()],\n    ({ matchText, range, stop }) => {\n      if (matchText.startsWith(\"'\") || matchText.startsWith('\"')) {\n        // matched attribute value: continue scanning\n        return\n      }\n\n      if (matchText !== '<') {\n        // matched end delimiter (\">\" or \"/>\"): assign position\n        position = [range.start.row, range.start.column + matchText.length]\n      }\n\n      stop()\n    }\n  )\n\n  return position\n}\n\n/**\n * Determines whether the next tag delimiter following the cursor in the current\n *  XML document is an end delimiter (\">\" / \"/>\"). Occurrences within attribute\n * values are ignored.\n */\nexport const nextTagDelimiterIsEndDelimiter = (\n  ctx: AutocompleteContext\n): boolean => {\n  return !!getNextTagEndDelimiterPosition(ctx)\n}\n\n/**\n * Creates attribute strings to be used in the `snippet` and `displayText`\n * properties of an autocomplete suggestion.\n * @param attNameWithNs An attribute name ([localname] or [prefix]:[localpart]),\n * optionally followed by \"#\" and the namespace of the attribute. Both attribute\n * name and namespace parts may contain wildcard characters \"*\" which get\n * converted into tabstop markers.\n * @param tabstopMarkerId The current tabstop marker ID. Each tabstop marker\n * added to the snippet gets the ID of the previous `tabstopMarkerId`\n * incremented by 1.\n * @param suggestAttributeValue Whether or not to include the attribute value\n * literal in the suggestion.\n */\nexport const createAttributeSuggestionTexts = (\n  attNameWithNs: string,\n  tabstopMarkerId: number,\n  suggestAttributeValue: boolean\n) => {\n  const [qName, nsUri] = attNameWithNs.split('#')\n\n  if (typeof nsUri === 'string') {\n    const nsPrefix = `ns\\${${++tabstopMarkerId}}`\n\n    // replace wildcards in the attribute name with tabstop markers\n    const attNameSnippet = qName.replace(\n      /\\*/g,\n      () => `\\${${++tabstopMarkerId}}`\n    )\n\n    // replace wildcard in `nsUri` with tabstop marker\n    const nsUriSnippet = nsUri === '*' ? `\\${${++tabstopMarkerId}}` : nsUri\n\n    // create optional attribute value fragment\n    const attValueSnippet = suggestAttributeValue\n      ? `=\"\\${${++tabstopMarkerId}}\"`\n      : ''\n\n    return {\n      snippet: `${nsPrefix}:${attNameSnippet}${attValueSnippet} xmlns:${nsPrefix}=\"${nsUriSnippet}\"`,\n      displayText:\n        nsUri === '' ? `${qName} [no namespace]` : `${qName} (${nsUri})`,\n      tabstopMarkerId,\n    }\n  }\n\n  // replace wildcards in the tag name with tabstop markers\n  const attNameSnippet = qName.replace(/\\*/g, () => `\\${${++tabstopMarkerId}}`)\n\n  // create optional attribute value fragment\n  const attValueSnippet = suggestAttributeValue\n    ? `=\"\\${${++tabstopMarkerId}}\"`\n    : ''\n\n  return {\n    snippet: `${attNameSnippet}${attValueSnippet}`,\n    displayText: qName,\n    tabstopMarkerId,\n  }\n}\n","export const nameStartChar = [\n  ':',\n  'A-Z',\n  '_',\n  'a-z',\n  '\\\\xC0-\\\\xD6',\n  '\\\\xD8-\\\\xF6',\n  '\\\\u00F8-\\\\u02FF',\n  '\\\\u0370-\\\\u037D',\n  '\\\\u037F-\\\\u1FFF',\n  '\\\\u200C-\\\\u200D',\n  '\\\\u2070-\\\\u218F',\n  '\\\\u2C00-\\\\u2FEF',\n  '\\\\u3001-\\\\uD7FF',\n  '\\\\uF900-\\\\uFDCF',\n  '\\\\uFDF0-\\\\uFFFD',\n  // '\\\\u10000-\\\\uEFFFF',\n].join('')\n\nexport const nameChar = [\n  nameStartChar,\n  '-',\n  '.',\n  '0-9',\n  '\\\\u00B7',\n  '\\\\u0300-\\\\u036F',\n  '\\\\u203F-\\\\u2040',\n].join('')\n\nexport const spaceChar = ' \\t\\r\\n'\n","import { ParserConfig } from '../getParserConfig'\nimport { AutocompleteConfig } from '../xmlService/util'\nimport XmlService, { RawSuggestion } from '../xmlService/XmlService'\nimport {\n  AutocompleteContext,\n  Suggestion,\n  createAttributeSuggestionTexts,\n  getNextTagEndDelimiterPosition,\n} from './util'\nimport { nameChar, nameStartChar } from './xmlChar'\n\nconst trailingAttNameStartRegex = new RegExp(\n  `[${nameStartChar}][${nameChar}]*$`\n)\nconst leadingAttributeRegex = new RegExp('^[' + nameChar + ']*=(\".*?\"|\\'.*?\\')')\n\n/**\n * Returns the attribute name fragment at the end of `str` or '' if there\n * is no match.\n */\nconst getTrailingAttNameFragment = (str: string) => {\n  const match = str.match(trailingAttNameStartRegex)\n  return match ? match[0] : ''\n}\n\n/**\n * Creates attribute name suggestions for autocomplete from RawSuggestion objects.\n */\nconst createAttributeNameSuggestions = (\n  rawSuggestions: Array<RawSuggestion>,\n  attNameFragmentPrecedingCursor: string,\n  suggestAttributeValue: boolean\n): Array<Suggestion> => {\n  return rawSuggestions\n    .filter((rawSuggestion: RawSuggestion) => {\n      // exclude suggestions that don't match `attNameFragmentPrecedingCursor`\n\n      return rawSuggestion.value.startsWith(attNameFragmentPrecedingCursor)\n    })\n    .map((rawSuggestion: RawSuggestion) => {\n      const { value, documentation } = rawSuggestion\n\n      const { snippet, displayText } = createAttributeSuggestionTexts(\n        value,\n        0,\n        suggestAttributeValue\n      )\n\n      return {\n        snippet,\n        displayText,\n        type: 'attribute',\n        replacementPrefix: attNameFragmentPrecedingCursor,\n        description: documentation ? documentation.join('\\n') : undefined,\n        retrigger: suggestAttributeValue,\n      }\n    })\n}\n\n/**\n * Returns attribute name suggestions.\n */\nconst getAttributeNameSuggestions = async (\n  ctx: AutocompleteContext,\n  autocompleteConfig: AutocompleteConfig,\n  parserConfig: ParserConfig,\n  xmlService: XmlService,\n  textPrecedingCursorInSameLine: string\n) => {\n  const { editor, bufferPosition } = ctx\n\n  const attNameFragmentPrecedingCursor = getTrailingAttNameFragment(\n    textPrecedingCursorInSameLine\n  )\n\n  const tagEndDelimiterPosition = getNextTagEndDelimiterPosition(ctx)\n\n  // don't suggest attribute names when the current tag doesn't have an end\n  // delimiter\n  if (!tagEndDelimiterPosition) return []\n\n  // The document text we're sending to the Java server is composed of all text\n  // preceding the current attribute and all text between the end of the\n  // current attribute and the end of the current element start tag. Thus, all\n  // other attributes of the element get sent to the Java server. This is to\n  // make sure that all namespaces declared in the element can be processed on\n  // the server and it further allows the server to exclude suggestions of\n  // attributes that already exist.\n\n  const documentTextPrecedingAttNameFragment = editor.getTextInBufferRange([\n    [0, 0],\n    [\n      bufferPosition.row,\n      bufferPosition.column - attNameFragmentPrecedingCursor.length,\n    ],\n  ])\n\n  const documentTextFromCursorToTagEndDelimiter = editor.getTextInBufferRange([\n    bufferPosition,\n    tagEndDelimiterPosition,\n  ])\n\n  // exclude current attribute from `documentTextFromCursorToTagEndDelimiter`\n  const leadingAttributeMatch = documentTextFromCursorToTagEndDelimiter.match(\n    leadingAttributeRegex\n  )\n  const documentTextFromAttEndToTagEndDelimiter = leadingAttributeMatch\n    ? documentTextFromCursorToTagEndDelimiter.substr(\n        leadingAttributeMatch[0].length\n      )\n    : documentTextFromCursorToTagEndDelimiter\n\n  // when the current attribute name is already followed by an attribute\n  // value in the current XML document, autocomplete should only insert the\n  // attribute name\n  const suggestAttributeValue = !leadingAttributeMatch\n\n  const body =\n    documentTextPrecedingAttNameFragment +\n    documentTextFromAttEndToTagEndDelimiter\n\n  // get raw suggestions from the Java server\n  const rawSuggestions = await xmlService.requestAutocompleteSuggestions(\n    parserConfig,\n    autocompleteConfig,\n    {\n      type: 'N',\n    },\n    body\n  )\n\n  return createAttributeNameSuggestions(\n    rawSuggestions,\n    attNameFragmentPrecedingCursor,\n    suggestAttributeValue\n  )\n}\n\nexport default getAttributeNameSuggestions\n","import { Point, TextEditor } from 'atom'\n\nimport { ParserConfig } from '../getParserConfig'\nimport { AutocompleteConfig } from '../xmlService/util'\nimport XmlService, { RawSuggestion } from '../xmlService/XmlService'\nimport {\n  AutocompleteContext,\n  Suggestion,\n  getNextTagEndDelimiterPosition,\n} from './util'\nimport { nameChar, nameStartChar, spaceChar } from './xmlChar'\n\nconst trailingTokenRegex = new RegExp(`[^${spaceChar}]+$`)\n\n/**\n * Returns the sequence of non-space characters at the end of `str` or, if\n * there is no such sequence, the empty string.\n */\nconst getTrailingToken = (str: string) => {\n  const match = str.match(trailingTokenRegex)\n  return match ? match[0] : ''\n}\n\n/**\n * Returns the byte index at `position` in the `editor`'s buffer.\n */\nconst getBufferIndex = (editor: TextEditor, position: Point) => {\n  const documentTextPrecedingPosition = editor.getTextInBufferRange([\n    [0, 0],\n    position,\n  ])\n  return Buffer.byteLength(documentTextPrecedingPosition)\n}\n\nconst attNameAndValueDoubleQuoteRegex = new RegExp(\n  `([${nameStartChar}][${nameChar}]*)=\"([^\"]*)`\n)\nconst attNameAndValueSingleQuoteRegex = new RegExp(\n  `([${nameStartChar}][${nameChar}]*)='([^']*)`\n)\n\n/**\n * Returns the attribute name and attribute value fragment preceding\n * the cursor or null if there's no match.\n */\nconst getAttributeNameAndValuePrecedingCursor = (\n  { editor, bufferPosition }: AutocompleteContext,\n  hasDblQuotes: boolean\n): { name: string; valueFragmentPrecedingCursor: string } | null => {\n  const regex = hasDblQuotes\n    ? attNameAndValueDoubleQuoteRegex\n    : attNameAndValueSingleQuoteRegex\n\n  let result\n\n  editor.backwardsScanInBufferRange(\n    regex,\n    [bufferPosition, [0, 0]],\n    ({ match, stop }) => {\n      result = match\n      stop()\n    }\n  )\n\n  return result\n    ? { name: result[1], valueFragmentPrecedingCursor: result[2] }\n    : null\n}\n\nconst singleQuoteAttValueReplacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  \"'\": '&apos;',\n}\n\nconst doubleQuoteAttValueReplacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '\"': '&quot;',\n}\n\n/**\n * Returns a function that replaces all substrings of `str` matching a key of\n * `replacements` with the corresponding value `replacements[key]`.\n */\nconst escape = (replacements: { [key: string]: string }) => {\n  const regex = new RegExp(Object.keys(replacements).join('|'), 'g')\n\n  return (str: string) => str.replace(regex, (match) => replacements[match])\n}\n\nconst escapeWithSingleQuotes = escape(singleQuoteAttValueReplacements)\nconst escapeWithDblQuotes = escape(doubleQuoteAttValueReplacements)\n\n/**\n * Creates attribute value suggestions for autocomplete from RawSuggestion\n * objects.\n */\nconst createAttributeValueSuggestions = (\n  rawSuggestions: Array<RawSuggestion>,\n  valueFragmentPrecedingCursor: string,\n  hasDblQuotes: boolean\n): Array<Suggestion> => {\n  const trailingTokenInValueFragment = getTrailingToken(\n    valueFragmentPrecedingCursor\n  )\n\n  return rawSuggestions\n    .filter((rawSuggestion: RawSuggestion) => {\n      // exclude suggestions that don't match the prefix\n\n      const { value, listItem } = rawSuggestion\n\n      return value.startsWith(\n        listItem ? trailingTokenInValueFragment : valueFragmentPrecedingCursor\n      )\n    })\n    .map(\n      (rawSuggestion: RawSuggestion): Suggestion => {\n        const { value, documentation, listItem } = rawSuggestion\n        return {\n          snippet: hasDblQuotes\n            ? escapeWithDblQuotes(value)\n            : escapeWithSingleQuotes(value),\n          displayText: value,\n          type: 'value',\n          rightLabel: listItem ? 'List Item' : undefined,\n          replacementPrefix: listItem\n            ? trailingTokenInValueFragment\n            : valueFragmentPrecedingCursor,\n          description: documentation ? documentation.join('\\n') : undefined,\n        }\n      }\n    )\n}\n\n/**\n * Returns suggestions for the value of an attribute.\n */\nconst getAttributeValueSuggestions = async (\n  ctx: AutocompleteContext,\n  autocompleteConfig: AutocompleteConfig,\n  parserConfig: ParserConfig,\n  xmlService: XmlService,\n  hasDblQuotes: boolean\n) => {\n  const { editor } = ctx\n\n  const currentAttribute = getAttributeNameAndValuePrecedingCursor(\n    ctx,\n    hasDblQuotes\n  )\n\n  if (!currentAttribute) return []\n\n  const tagEndDelimiterPosition = getNextTagEndDelimiterPosition(ctx)\n\n  // don't suggest attribute values when the current tag doesn't have an end\n  // delimiter\n  if (!tagEndDelimiterPosition) return []\n\n  const body = editor.getText()\n\n  // get raw suggestions from the Java server\n  const rawSuggestions = await xmlService.requestAutocompleteSuggestions(\n    parserConfig,\n    autocompleteConfig,\n    {\n      type: 'V',\n      attName: currentAttribute.name,\n      tagEndDelimiterBufferIndex: getBufferIndex(\n        editor,\n        tagEndDelimiterPosition\n      ),\n    },\n    body\n  )\n\n  return createAttributeValueSuggestions(\n    rawSuggestions,\n    currentAttribute.valueFragmentPrecedingCursor,\n    hasDblQuotes\n  )\n}\n\nexport default getAttributeValueSuggestions\n","import { ParserConfig } from '../getParserConfig'\nimport { AutocompleteConfig } from '../xmlService/util'\nimport XmlService, { RawSuggestion } from '../xmlService/XmlService'\nimport {\n  AutocompleteContext,\n  Suggestion,\n  createAttributeSuggestionTexts,\n  nextTagDelimiterIsEndDelimiter,\n} from './util'\n\n/**\n * Creates an autocomplete Suggestion for an element start tag.\n */\nconst createStartTagSuggestion = (\n  rawSuggestion: RawSuggestion,\n  markupFragmentPrecedingCursor: string,\n  suggestOnlyTagName: boolean\n): Suggestion => {\n  const { value, empty, attributes = [], documentation } = rawSuggestion\n\n  // `value` is and element name ([localname] or [prefix]:[localpart]),\n  // optionally followed by \"#\" and the namespace of the element. Both element\n  // name and namespace parts may contain wildcard characters \"*\" which get\n  // converted into tabstop markers\n  const [tagName, nsUri] = value.split('#')\n\n  // the current tabstop marker ID. Each tabstop marker added to the suggestion\n  // snippet gets the ID of the previous `tabstopMarkerId` incremented by 1\n  let tabstopMarkerId = 0\n\n  // replace wildcards in the tag name with tabstop markers\n  const tagNameSnippet = tagName.replace(\n    /\\*/g,\n    () => `\\${${++tabstopMarkerId}}`\n  )\n\n  if (suggestOnlyTagName) {\n    return {\n      snippet: tagNameSnippet,\n      displayText: tagName,\n      type: 'tag',\n      replacementPrefix: markupFragmentPrecedingCursor,\n      description: documentation ? documentation.join('\\n') : undefined,\n      retrigger: false,\n    }\n  }\n\n  const hasTabstopMarkerInTagName = tabstopMarkerId > 0\n\n  let displayText\n  let nsSnippet: Array<string> | undefined\n\n  if (typeof nsUri === 'string') {\n    // replace wildcard in `nsUri` with tabstop marker\n    const nsUriSnippet = nsUri === '*' ? `\\${${++tabstopMarkerId}}` : nsUri\n\n    nsSnippet = [`xmlns=\"${nsUriSnippet}\"`]\n    displayText =\n      nsUri === '' ? `${tagName} [no namespace]` : `${tagName} (${nsUri})`\n  } else {\n    nsSnippet = []\n    displayText = tagName\n  }\n\n  const attributeSnippets = attributes.map((attribute) => {\n    const {\n      snippet: attributeSnippet,\n      tabstopMarkerId: newTabstopMarkerId,\n    } = createAttributeSuggestionTexts(attribute, tabstopMarkerId, true)\n    tabstopMarkerId = newTabstopMarkerId\n    return attributeSnippet\n  })\n\n  const startTagContent = [tagNameSnippet]\n    .concat(nsSnippet)\n    .concat(attributeSnippets)\n    .join(' ')\n\n  const snippet = empty\n    ? startTagContent + '/>'\n    : `${startTagContent}>\\${${++tabstopMarkerId}}</${tagNameSnippet}>`\n\n  // only retrigger autocomplete when there are tabstop markers and the\n  // first tabstop marker is not located in the tag name\n  const retrigger = tabstopMarkerId > 0 && !hasTabstopMarkerInTagName\n\n  return {\n    snippet,\n    displayText,\n    type: 'tag',\n    replacementPrefix: markupFragmentPrecedingCursor,\n    description: documentation ? documentation.join('\\n') : undefined,\n    retrigger,\n  }\n}\n\n/**\n * Creates an autocomplete Suggestion for an element end tag.\n */\nconst createEndTagSuggestion = (\n  rawSuggestion: RawSuggestion,\n  markupFragmentPrecedingCursor: string,\n  suggestOnlyTagName: boolean\n): Suggestion => {\n  const { value } = rawSuggestion\n  const snippet = suggestOnlyTagName ? `/${value}` : `/${value}>`\n\n  return {\n    snippet,\n    displayText: snippet,\n    type: 'tag',\n    replacementPrefix: markupFragmentPrecedingCursor,\n    description: 'Element End Tag',\n    retrigger: false,\n  }\n}\n\ninterface StaticRawSuggestion {\n  value: string\n  snippet: string\n  description: string\n}\n\n/**\n * Creates an autocomplete Suggestion for statically defined markup\n * suggestions.\n */\nconst createStaticMarkupSuggestion = (\n  rawSuggestion: StaticRawSuggestion,\n  markupFragmentPrecedingCursor: string\n): Suggestion => {\n  const { value, snippet, description } = rawSuggestion\n\n  return {\n    snippet,\n    displayText: value,\n    type: 'tag',\n    replacementPrefix: markupFragmentPrecedingCursor,\n    description,\n    retrigger: false,\n  }\n}\n\n/**\n * Suggestion data to be added statically to the data received from the Java\n * server, given that the markup start fragment preceding the cursor matches\n * the `value`.\n */\nconst rawStaticMarkupSuggestions: Array<StaticRawSuggestion> = [\n  {\n    value: '!--  -->',\n    snippet: '!-- ${1} -->', // eslint-disable-line no-template-curly-in-string\n    description: 'Comment',\n  },\n  {\n    value: '![CDATA[]]>',\n    snippet: '![CDATA[${1}]]>', // eslint-disable-line no-template-curly-in-string\n    description: 'CDATA Section',\n  },\n]\n\n/**\n * Creates markup suggestions for autocomplete from RawSuggestion objects\n * received from the Java server and static markup suggestions.\n */\nconst createMarkupSuggestions = (\n  rawSuggestions: Array<RawSuggestion>,\n  markupFragmentPrecedingCursor: string,\n  suggestOnlyTagName: boolean\n): Array<Suggestion> => {\n  return rawSuggestions\n    .concat(rawStaticMarkupSuggestions)\n    .filter((rawSuggestions: RawSuggestion | StaticRawSuggestion): boolean => {\n      // exclude suggestions that don't match the markup start fragment\n\n      const valueToMatch =\n        'closing' in rawSuggestions && rawSuggestions.closing\n          ? '/' + rawSuggestions.value\n          : rawSuggestions.value\n\n      return valueToMatch.startsWith(markupFragmentPrecedingCursor)\n    })\n    .map(\n      (rawSuggestions: RawSuggestion | StaticRawSuggestion): Suggestion => {\n        if ('snippet' in rawSuggestions) {\n          // the `snippet` property is only set on static markup suggestions\n          return createStaticMarkupSuggestion(\n            rawSuggestions,\n            markupFragmentPrecedingCursor\n          )\n        }\n\n        if (rawSuggestions.closing) {\n          // suggest end tag\n          return createEndTagSuggestion(\n            rawSuggestions,\n            markupFragmentPrecedingCursor,\n            suggestOnlyTagName\n          )\n        }\n\n        // suggest start tag\n        return createStartTagSuggestion(\n          rawSuggestions,\n          markupFragmentPrecedingCursor,\n          suggestOnlyTagName\n        )\n      }\n    )\n}\n\n/**\n * Returns suggestions following a markup start fragment: element tags,\n * comments and CDATA section markup.\n */\nconst getMarkupSuggestions = async (\n  ctx: AutocompleteContext,\n  autocompleteConfig: AutocompleteConfig,\n  parserConfig: ParserConfig,\n  xmlService: XmlService,\n  markupFragmentPrecedingCursor: string\n) => {\n  const { editor, bufferPosition } = ctx\n\n  // get all text preceding the current markup fragment from the XML document\n  // for parsing in Java\n  const body = editor.getTextInBufferRange([\n    [0, 0],\n    [\n      bufferPosition.row,\n      // we need to subtract 1 from `markupFragmentPrecedingCursor.length` since\n      // `markupFragmentPrecedingCursor` doesn't include the initial '<'\n      bufferPosition.column - markupFragmentPrecedingCursor.length - 1,\n    ],\n  ])\n\n  // get raw suggestions from the Java server\n  const rawSuggestions = await xmlService.requestAutocompleteSuggestions(\n    parserConfig,\n    autocompleteConfig,\n    {\n      type: 'E',\n    },\n    body\n  )\n\n  // when the cursor is followed by a tag end delimiter,\n  // only the name of an element tag should get suggested\n  const suggestOnlyTagName = nextTagDelimiterIsEndDelimiter(ctx)\n\n  return createMarkupSuggestions(\n    rawSuggestions,\n    markupFragmentPrecedingCursor,\n    suggestOnlyTagName\n  )\n}\n\nexport default getMarkupSuggestions\n","import { ParserConfig } from '../getParserConfig'\nimport { AutocompleteConfig } from '../xmlService/util'\nimport XmlService from '../xmlService/XmlService'\nimport getAttributeNameSuggestions from './getAttributeNameSuggestions'\nimport getAttributeValueSuggestions from './getAttributeValueSuggestions'\nimport getMarkupSuggestions from './getMarkupSuggestions'\nimport {\n  AutocompleteContext,\n  precedingTagDelimiterIsStartTagStartDelimiter,\n} from './util'\nimport { nameChar, nameStartChar } from './xmlChar'\n\n/**\n * Returns the text preceding the cursor in the same line.\n */\nconst getTextPrecedingCursorInSameLine = ({\n  editor,\n  bufferPosition,\n}: AutocompleteContext) =>\n  editor.getTextInBufferRange([[bufferPosition.row, 0], bufferPosition])\n\nconst trailingMarkupRegex = new RegExp(\n  `<(!|/|/?[${nameStartChar}][${nameChar}]*)?$`\n)\n\n/**\n * Returns the substring at the end of `str` following a '<' and matching\n * '', '!', '/', '[tag chars]' or '/[tag chars]'.\n * Returns null if there's no match.\n */\nconst getTrailingMarkupFragment = (str: string) => {\n  const match = str.match(trailingMarkupRegex)\n  return match ? match[1] || '' : null\n}\n\n/**\n * Checks whether the provided scopes include a tag scope.\n */\nconst hasTagScope = (scopes: readonly string[]) =>\n  scopes.some(\n    (item) =>\n      item.startsWith('meta.tag.xml') || item === 'meta.tag.no-content.xml'\n  )\n\n/**\n * Returns the 'quoted string' scope from the provided scopes. If no such scope\n * exists, returns `undefined`.\n */\nconst getQuotedScope = (scopes: readonly string[]) =>\n  scopes.find(\n    (scope) =>\n      scope === 'string.quoted.double.xml' ||\n      scope === 'string.quoted.single.xml'\n  )\n\n/**\n * Requests suggestions for the current XML document at the current cursor\n * position from the XMLService and transforms the response into autocomplete\n * suggestions.\n */\nconst suggest = (\n  ctx: AutocompleteContext,\n  autocompleteConfig: AutocompleteConfig,\n  parserConfig: ParserConfig,\n  xmlService: XmlService\n) => {\n  const textPrecedingCursorInSameLine = getTextPrecedingCursorInSameLine(ctx)\n\n  const markupFragmentPrecedingCursor = getTrailingMarkupFragment(\n    textPrecedingCursorInSameLine\n  )\n  if (markupFragmentPrecedingCursor !== null) {\n    // cursor is preceded by a markup start fragment -> suggest markup\n    return getMarkupSuggestions(\n      ctx,\n      autocompleteConfig,\n      parserConfig,\n      xmlService,\n      markupFragmentPrecedingCursor\n    )\n  }\n\n  // get the scopes at the cursor position\n  const scopes = ctx.scopeDescriptor.getScopesArray()\n\n  if (hasTagScope(scopes)) {\n    // cursor is within element tag\n\n    const quotedScope = getQuotedScope(scopes)\n    if (quotedScope) {\n      // cursor is in attribute value literal -> suggest attribute value\n\n      const hasDblQuotes = quotedScope === 'string.quoted.double.xml'\n\n      return getAttributeValueSuggestions(\n        ctx,\n        autocompleteConfig,\n        parserConfig,\n        xmlService,\n        hasDblQuotes\n      )\n    }\n\n    if (precedingTagDelimiterIsStartTagStartDelimiter(ctx)) {\n      // cursor is within element start tag -> suggest attribute name\n      return getAttributeNameSuggestions(\n        ctx,\n        autocompleteConfig,\n        parserConfig,\n        xmlService,\n        textPrecedingCursorInSameLine\n      )\n    }\n  }\n\n  return Promise.resolve([])\n}\n\nexport default suggest\n",";(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'opentagstart',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  function isWhitespace (c) {\n    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t'\n  }\n\n  function isQuote (c) {\n    return c === '\"' || c === '\\''\n  }\n\n  function isAttribEnd (c) {\n    return c === '>' || isWhitespace(c)\n  }\n\n  function isMatch (regex, c) {\n    return regex.test(c)\n  }\n\n  function notMatch (regex, c) {\n    return !isMatch(regex, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n    emitNode(parser, 'onopentagstart', tag)\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function charAt (chunk, i) {\n    var result = ''\n    if (i < chunk.length) {\n      result = chunk.charAt(i)\n    }\n    return result\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    if (typeof chunk === 'object') {\n      chunk = chunk.toString()\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = charAt(chunk, i++)\n      parser.c = c\n\n      if (!c) {\n        break\n      }\n\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = charAt(chunk, i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (isWhitespace(c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue\n          } else if (isQuote(c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser)\n            parser.entity = ''\n            parser.state = returnState\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n","import { PointCompatible, TextEditor } from 'atom'\n\nexport type RangeCompatible = [[number, number], [number, number]]\n\n// literal copy of https://github.com/steelbrain/atom-linter/blob/master/src/helpers.js#L15-L18\nfunction escapeRegexp(string: string): string {\n  // Shamelessly stolen from https://github.com/atom/underscore-plus/blob/130913c179fe1d718a14034f4818adaf8da4db12/src/underscore-plus.coffee#L138\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n\n// literal copy of https://github.com/steelbrain/atom-linter/blob/master/src/helpers.js#L20-L30\nfunction getWordRegexp(\n  textEditor: TextEditor,\n  bufferPosition: PointCompatible\n) {\n  const scopeDescriptor = textEditor.scopeDescriptorForBufferPosition(\n    bufferPosition\n  )\n  const nonWordCharacters = escapeRegexp(\n    atom.config.get('editor.nonWordCharacters', {\n      scope: scopeDescriptor,\n    })\n  )\n  return new RegExp(`^[\\t ]*$|[^\\\\s${nonWordCharacters}]+`)\n}\n\n// literal copy of https://github.com/steelbrain/atom-linter/blob/master/src/helpers.js#L20-L30\nfunction validateEditor(editor: TextEditor) {\n  let isEditor\n  if (typeof atom.workspace.isTextEditor === 'function') {\n    // Added in Atom v1.4.0\n    isEditor = atom.workspace.isTextEditor(editor)\n  } else {\n    isEditor = typeof editor.getText === 'function'\n  }\n  if (!isEditor) {\n    throw new Error('Invalid TextEditor provided')\n  }\n}\n\n// modified copy of https://github.com/steelbrain/atom-linter/blob/master/src/helpers.js#L20-L30\nfunction generateRange(textEditor: TextEditor, line?: number): RangeCompatible {\n  validateEditor(textEditor)\n  let lineNumber = line\n\n  if (\n    typeof lineNumber !== 'number' ||\n    !Number.isFinite(lineNumber) ||\n    lineNumber < 0\n  ) {\n    lineNumber = 0\n  }\n\n  const buffer = textEditor.getBuffer()\n  const lineMax = buffer.getLineCount() - 1\n\n  if (lineNumber > lineMax) {\n    throw new Error(\n      `Line number (${lineNumber}) greater than maximum line (${lineMax})`\n    )\n  }\n\n  const columnGiven = false\n  const lineText = buffer.lineForRow(lineNumber) ?? ''\n  let colEnd = lineText.length\n  let colStart = 0\n  if (columnGiven) {\n    const match = getWordRegexp(textEditor, [lineNumber, colStart]).exec(\n      lineText\n    )\n    if (match) {\n      colEnd = colStart + match.index + match[0].length\n    }\n  } else {\n    const indentation = lineText.match(/^\\s+/)\n    if (indentation) {\n      colStart = indentation[0].length\n    }\n  }\n  if (colStart > lineText.length) {\n    throw new Error(\n      `Column start (${colStart || 0}) greater than line length (${\n        lineText.length\n      }) for line ${lineNumber}`\n    )\n  }\n\n  return [\n    [lineNumber, colStart],\n    [lineNumber, colEnd],\n  ]\n}\n\nexport default generateRange\n","import path from 'path'\n\nimport { TextEditor } from 'atom'\nimport sax from 'sax'\n\nimport RuleStore, {\n  Attributes,\n  DocumentProps,\n  SchemaLang,\n} from './rules/RuleStore'\nimport generateRange, { RangeCompatible } from './util/generateRange'\n\nexport interface DefaultParserConfig {\n  xmlCatalog: string\n  dtdValidation: 'never' | 'always' | 'fallback'\n  xIncludeAware: boolean\n  xIncludeFixupBaseUris: boolean\n  xIncludeFixupLanguage: boolean\n}\n\nexport interface SchemaPropsWithLine {\n  lang: SchemaLang\n  path: string | null\n  lineOfReference?: number\n}\n\n/**\n * Request-specific parser settings to be passed to the Java server.\n */\nexport interface ParserConfig {\n  filePath?: string\n  schemaProps: Array<SchemaPropsWithLine>\n  xmlCatalog: string\n  xIncludeAware: boolean\n  xIncludeFixupBaseUris: boolean\n  xIncludeFixupLanguage: boolean\n}\n\nexport interface LinterMessage {\n  severity: 'warning' | 'error'\n  excerpt: string\n  location: {\n    file?: string\n    position: RangeCompatible\n  }\n}\n\nconst urlRegex = /^(?:[a-z][a-z0-9+\\-.]*:)?\\/\\//i\n\n// the sax module eliminates linebreak characters in DOCTYPE so we need to\n// match `\\s*` instead of `\\s+`\nconst publicIdRegex = /\\s*[^\\s]+\\s*PUBLIC\\s*(\"([^\"]+)\"|'([^']+)')/\n\n/**\n * Extracts pseudo attributes from the data string of a processing instruction.\n */\nconst getPseudoAttsFromPIData = (piData: string) => {\n  const pseudoAtts: Attributes = {}\n  piData.replace(/(\\w+)=\"(.+?)\"/g, (_, key, value) => (pseudoAtts[key] = value))\n  return pseudoAtts\n}\n\nconst getXsiNamespacePrefixes = (attributes: Attributes) => {\n  const prefixes: Array<string> = []\n  Object.keys(attributes).forEach((key) => {\n    const match = key.match(/xmlns:(.*)/)\n    if (\n      match &&\n      attributes[key] === 'http://www.w3.org/2001/XMLSchema-instance'\n    ) {\n      prefixes.push(match[1])\n    }\n  })\n  return prefixes\n}\n\nconst isOddNumber = (n: number) => !!(n % 2)\n\n/**\n * Splits a QName into prefix and localpart.\n */\nconst splitQName = (qName: string): [prefix: string, localpart: string] => {\n  const colonIndex = qName.indexOf(':')\n  return [qName.substr(0, colonIndex), qName.substr(colonIndex + 1)]\n}\n\n/**\n * Gets the configuration settings to be used by the Java parser such as parser\n * flags, schema and catalog information by pre-parsing the start of the\n * document and then adjusting the results with the `RuleOutcome` applying to\n * to the document.\n */\nconst getParserConfig = (\n  textEditor: TextEditor,\n  ruleStore: RuleStore,\n  defaults: DefaultParserConfig\n): {\n  xmlModelWarnings: Array<LinterMessage>\n  parserConfig: ParserConfig\n} => {\n  const filePath = textEditor.getPath()\n  const baseUri = filePath ? path.dirname(filePath) : __dirname\n\n  const xmlModelWarnings: Array<LinterMessage> = []\n  const schemaProps: Array<SchemaPropsWithLine> = []\n  const xsdSchemaPaths: Array<string> = []\n  const saxParser = sax.parser(true)\n\n  let row = 0\n  let done = false\n  let hasDoctype = false\n  let rootNs\n  let rootLocalName\n  let rootAttributes = {}\n  let publicId\n\n  const addXsdSchemaPath = (href?: string) =>\n    href &&\n    xsdSchemaPaths.push(\n      urlRegex.test(href) ? href : path.resolve(baseUri, href)\n    )\n\n  saxParser.onerror = () => (done = true)\n\n  saxParser.ondoctype = (str) => {\n    hasDoctype = true\n    const match = str.match(publicIdRegex)\n    if (match) {\n      publicId = match[2] || match[3]\n    }\n  }\n\n  saxParser.onprocessinginstruction = (node: {\n    name: string\n    body: string\n  }) => {\n    if (node.name !== 'xml-model') return\n\n    const { href, type, schematypens } = getPseudoAttsFromPIData(node.body)\n\n    let lang: SchemaLang | null = null\n    if (href) {\n      if (type === 'application/relax-ng-compact-syntax') {\n        lang = 'rnc'\n      } else if (schematypens === 'http://relaxng.org/ns/structure/1.0') {\n        lang = path.extname(href) === '.rnc' ? 'rnc' : 'rng'\n      } else if (schematypens === 'http://purl.oclc.org/dsdl/schematron') {\n        lang = 'sch.iso'\n      } else if (schematypens === 'http://www.ascc.net/xml/schematron') {\n        lang = 'sch.15'\n      } else if (schematypens === 'http://www.w3.org/2001/XMLSchema') {\n        addXsdSchemaPath(href)\n      } else {\n        xmlModelWarnings.push({\n          severity: 'warning',\n          excerpt: 'Unknown schema type',\n          location: {\n            file: filePath,\n            position: generateRange(textEditor, row),\n          },\n        })\n      }\n    }\n\n    if (lang) {\n      schemaProps.push({\n        lang,\n        lineOfReference: row,\n        path: urlRegex.test(href) ? href : path.resolve(baseUri, href),\n      })\n    }\n  }\n\n  saxParser.onopentag = (node: sax.Tag) => {\n    if (done) return\n\n    const [rootNsPrefix, localName] = splitQName(node.name)\n    rootNs = rootNsPrefix\n      ? node.attributes['xmlns:' + rootNsPrefix]\n      : node.attributes.xmlns\n    rootLocalName = localName\n    rootAttributes = node.attributes\n\n    getXsiNamespacePrefixes(node.attributes).forEach((prefix) => {\n      const noNamespaceSchemaLocation =\n        node.attributes[prefix + ':noNamespaceSchemaLocation']\n      if (noNamespaceSchemaLocation) {\n        addXsdSchemaPath(noNamespaceSchemaLocation.trim())\n      }\n\n      const schemaLocation = node.attributes[prefix + ':schemaLocation']\n      if (schemaLocation) {\n        schemaLocation\n          .trim()\n          .split(/[ \\t\\r\\n]+/)\n          // the value of `schemaLocation` is a sequence of `[ns] [uri]` pairs\n          // but we only need the URIs\n          .filter((_: string, index: number) => isOddNumber(index))\n          .forEach(addXsdSchemaPath)\n      }\n    })\n\n    done = true\n  }\n\n  const textBuffer = textEditor.getBuffer()\n  const lineCount = textBuffer.getLineCount()\n  const chunkSize = 64\n\n  while (!done && row < lineCount) {\n    const line = textBuffer.lineForRow(row) || ''\n    const lineLength = line.length\n    let column = 0\n    while (!done && column < lineLength) {\n      saxParser.write(line.substr(column, chunkSize))\n      column += chunkSize\n    }\n    row++\n  }\n\n  if (xsdSchemaPaths.length) {\n    schemaProps.push({\n      lang: 'xsd',\n      path: xsdSchemaPaths.join('*'),\n    })\n  }\n\n  const docProps: DocumentProps = {\n    rootScopes: textEditor.getRootScopeDescriptor().getScopesArray(),\n    filePath,\n    rootNs,\n    rootLocalName,\n    rootAttributes,\n    publicId,\n  }\n\n  const ruleOutcome = ruleStore.getMatchingOutcome(docProps)\n\n  const xmlCatalog = ruleOutcome?.xmlCatalog ?? defaults.xmlCatalog\n  const dtdValidation = ruleOutcome?.dtdValidation ?? defaults.dtdValidation\n  const xIncludeAware = ruleOutcome?.xIncludeAware ?? defaults.xIncludeAware\n  const xIncludeFixupBaseUris =\n    ruleOutcome?.xIncludeFixupBaseUris ?? defaults.xIncludeFixupBaseUris\n  const xIncludeFixupLanguage =\n    ruleOutcome?.xIncludeFixupLanguage ?? defaults.xIncludeFixupLanguage\n\n  // `schemaProps` from rules should only apply when there are no schema hints\n  // in the current document\n  if (!schemaProps.length && ruleOutcome?.schemaProps) {\n    schemaProps.push(...ruleOutcome.schemaProps)\n  }\n\n  // add DTD validation depending on the `dtdValidation` user setting\n  if (\n    hasDoctype &&\n    (dtdValidation === 'always' ||\n      (dtdValidation === 'fallback' && !schemaProps.length))\n  ) {\n    schemaProps.push({\n      lang: 'dtd',\n      path: null,\n      lineOfReference: saxParser.line,\n    })\n  }\n\n  if (!schemaProps.length) {\n    schemaProps.push({\n      lang: 'none',\n      path: null,\n    })\n  }\n\n  return {\n    xmlModelWarnings,\n\n    parserConfig: {\n      filePath,\n      schemaProps,\n      xmlCatalog,\n      xIncludeAware,\n      xIncludeFixupBaseUris,\n      xIncludeFixupLanguage,\n    },\n  }\n}\n\nexport default getParserConfig\n","const logError = (message: string, error?: Error) => {\n  error\n    ? console.error(`[linter-autocomplete-jing] ${message}`, error) // eslint-disable-line no-console\n    : console.error(`[linter-autocomplete-jing] ${message}`) // eslint-disable-line no-console\n}\n\nexport default logError\n","import { Rule } from './RuleStore'\n\nconst isArray = Array.isArray\n\nconst isNumber = (value: unknown) => {\n  return typeof value === 'number' && isFinite(value)\n}\n\nconst isObject = (obj: unknown): obj is Record<string, unknown> => {\n  return Object.prototype.toString.call(obj) === '[object Object]'\n}\n\nconst isString = (value: unknown) => {\n  return typeof value === 'string'\n}\n\nconst validateRule = (rule: unknown): rule is Rule => {\n  if (!isObject(rule)) {\n    throw new Error('Rule must be an object.')\n  }\n\n  if (!('test' in rule) || !('outcome' in rule)) {\n    throw new Error('Rules must to have \"test\" and \"outcome\" properties.')\n  }\n\n  if ('priority' in rule && !isNumber(rule.priority)) {\n    throw new Error('\"priority\" must be a number.')\n  }\n\n  if (!isObject(rule.test)) {\n    throw new Error('\"test\" must be an object.')\n  }\n\n  if (!isObject(rule.outcome)) {\n    throw new Error('\"outcome\" must be an object.')\n  }\n\n  if ('grammarScope' in rule.test && !isString(rule.test.grammarScope)) {\n    throw new Error('\"test.grammarScope\" must be a string.')\n  }\n\n  if ('pathRegex' in rule.test && !isString(rule.test.pathRegex)) {\n    throw new Error('\"test.pathRegex\" must be a string.')\n  }\n\n  if ('rootNs' in rule.test && !isString(rule.test.rootNs)) {\n    throw new Error('\"test.rootNs\" must be a string.')\n  }\n\n  if ('rootLocalName' in rule.test && !isString(rule.test.rootLocalName)) {\n    throw new Error('\"test.rootLocalName\" must be a string.')\n  }\n\n  if ('rootAttributes' in rule.test && !isObject(rule.test.rootAttributes)) {\n    throw new Error('\"test.rootAttributes\" must be an object.')\n  }\n\n  if ('xmlCatalog' in rule.outcome && !isString(rule.outcome.xmlCatalog)) {\n    throw new Error('\"outcome.xmlCatalog\" must be a string.')\n  }\n\n  if (\n    'dtdValidation' in rule.outcome &&\n    rule.outcome.dtdValidation !== 'never' &&\n    rule.outcome.dtdValidation !== 'always' &&\n    rule.outcome.dtdValidation !== 'fallback'\n  ) {\n    throw new Error(\n      '\"outcome.dtdValidation\" must be \"never\", \"always\" or \"fallback\".'\n    )\n  }\n\n  if ('schemaProps' in rule.outcome) {\n    if (!isArray(rule.outcome.schemaProps)) {\n      throw new Error('\"outcome.schemaProps\" must be an array.')\n    }\n\n    rule.outcome.schemaProps.forEach((schemaProps, index) => {\n      if (!isObject(schemaProps)) {\n        throw new Error(`\"outcome.schemaProps[${index}]\" must be an object.`)\n      }\n\n      if (!('lang' in schemaProps) || !('path' in schemaProps)) {\n        throw new Error(\n          `\"outcome.schemaProps[${index}]\" must have \"lang\" and \"path\" properties.`\n        )\n      }\n\n      if (!isString(schemaProps.lang)) {\n        throw new Error(\n          `\"outcome.schemaProps[${index}].lang\" must be a string.`\n        )\n      }\n\n      if (!isString(schemaProps.path)) {\n        throw new Error(\n          `\"outcome.schemaProps[${index}].path\" must be a string.`\n        )\n      }\n    })\n  }\n\n  return true\n}\n\nconst validateRules = (rules: Array<unknown>): rules is Array<Rule> => {\n  rules.forEach((rule, index) => {\n    try {\n      validateRule(rule)\n    } catch (err) {\n      throw new Error(`Error in rule at index ${index}: ${err.message}`)\n    }\n  })\n\n  return true\n}\n\nexport default validateRules\n","import path from 'path'\n\nimport { Package } from 'atom'\n\nimport logError from '../util/logError'\nimport { Rule, RuleOutcome } from './RuleStore'\nimport validateRules from './validateRules'\n\ninterface SettingsFile {\n  path: string\n  properties?: {\n    '.text.xml'?: {\n      validation?: {\n        rules?: unknown\n      }\n    }\n  }\n}\n\ndeclare module 'atom' {\n  interface Package {\n    settings?: Array<SettingsFile>\n  }\n}\n\n/**\n * Resolves paths in a RuleOutcome relative to a base path.\n */\nconst resolvePaths = (outcome: RuleOutcome, baseDir: string): RuleOutcome => {\n  const newOutcome: RuleOutcome = { ...outcome }\n\n  if (newOutcome.xmlCatalog) {\n    // resolve newOutcome.xmlCatalog relative to `baseDir`\n    newOutcome.xmlCatalog = path.resolve(baseDir, newOutcome.xmlCatalog)\n  }\n  if (newOutcome.schemaProps) {\n    // resolve all newOutcome.schemaProps `path`s relative to `baseDir`\n    newOutcome.schemaProps = newOutcome.schemaProps.map(\n      ({ path: schemaPath, lang }) => ({\n        path: path.resolve(baseDir, schemaPath),\n        lang,\n      })\n    )\n  }\n\n  return newOutcome\n}\n\nconst getSettingsFiles = (packages: Array<Package>): Array<SettingsFile> => {\n  return packages.reduce((result, pkg: Package) => {\n    const { settings } = pkg\n\n    if (Array.isArray(settings)) {\n      return result.concat(settings)\n    }\n\n    return result\n  }, [] as Array<SettingsFile>)\n}\n\n/**\n * Extracts linter-autocomplete-jing rules from an array of Atom packages and\n * resolves paths in the rules' outcomes relative to the package's settings\n * directory.\n */\nconst getRulesFromAtomPackages = (packages: Array<Package>): Array<Rule> => {\n  const settingsFiles = getSettingsFiles(packages)\n\n  return settingsFiles.reduce((result, settings) => {\n    const { path: settingsPath, properties } = settings\n\n    const rules = properties?.['.text.xml']?.validation?.rules\n\n    if (!settingsPath || !Array.isArray(rules)) return result\n\n    try {\n      validateRules(rules)\n    } catch (err) {\n      logError(`Skipping rules from ${settingsPath}: ${err.message}`)\n      return result\n    }\n\n    const settingsDir = path.dirname(settingsPath)\n\n    const newRules = rules.map(({ priority, test, outcome }) => ({\n      priority,\n      test,\n      outcome: resolvePaths(outcome, settingsDir),\n    }))\n\n    return result.concat(newRules)\n  }, [] as Array<Rule>)\n}\n\nexport default getRulesFromAtomPackages\n","import logError from '../util/logError'\n\n/**\n * The properties of the active document used to determine whether the document\n * matches a schema/catalog assignment rule\n */\nexport interface DocumentProps {\n  rootScopes: readonly string[]\n  filePath?: string\n  rootNs?: string\n  rootLocalName?: string\n  rootAttributes: Attributes\n  publicId?: string\n}\n\nexport interface Attributes {\n  [key: string]: string\n}\n\ninterface RuleTestSpecs {\n  grammarScope?: string\n  pathRegex?: string\n  rootNs?: string\n  rootLocalName?: string\n  rootAttributes?: Attributes\n  publicId?: string\n}\n\nexport type SchemaLang =\n  | 'rng'\n  | 'rnc'\n  | 'sch.iso'\n  | 'sch.15'\n  | 'xsd'\n  | 'dtd'\n  | 'none'\n\ninterface SchemaProps {\n  path: string\n  lang: SchemaLang\n}\n\nexport interface RuleOutcome {\n  xmlCatalog?: string\n  schemaProps?: Array<SchemaProps>\n  dtdValidation?: 'never' | 'always' | 'fallback'\n  xIncludeAware?: boolean\n  xIncludeFixupBaseUris?: boolean\n  xIncludeFixupLanguage?: boolean\n}\n\nexport interface Rule {\n  priority?: number\n  test: RuleTestSpecs\n  outcome: RuleOutcome\n}\n\n/**\n * A function to test whether the properties of an XML document match a\n * schema/catalog assignment rule.\n */\ninterface RuleMatcher {\n  (documentProps: DocumentProps): boolean\n}\n\ninterface RuleWithMatcher {\n  matches: RuleMatcher\n  outcome: RuleOutcome\n}\n\nconst createGrammarScopeConstraint = (value: string): RuleMatcher => ({\n  rootScopes,\n}) => rootScopes.includes(value)\n\nconst createPathRegexConstraint = (pattern: string): RuleMatcher => {\n  try {\n    const pathRegex = new RegExp(pattern)\n\n    return ({ filePath }) => (filePath ? pathRegex.test(filePath) : false)\n  } catch (err) {\n    logError(`Could not parse RegExp \"${pattern}\"`, err)\n    return () => false\n  }\n}\n\nconst createRootNsConstraint = (value: string): RuleMatcher => ({ rootNs }) =>\n  value === rootNs\n\nconst createRootLocalNameConstraint = (value: string): RuleMatcher => ({\n  rootLocalName,\n}) => value === rootLocalName\n\nconst createRootAttributeConstraint = (\n  name: string,\n  value: string\n): RuleMatcher => ({ rootAttributes }) => rootAttributes[name] === value\n\nconst createPublicIdConstraint = (value: string): RuleMatcher => ({\n  publicId,\n}) => value === publicId\n\nconst createDocumentPropsMatcher = ({\n  grammarScope,\n  pathRegex,\n  rootNs,\n  rootLocalName,\n  rootAttributes,\n  publicId,\n}: RuleTestSpecs): RuleMatcher => {\n  const tests: Array<RuleMatcher> = []\n  if (grammarScope) {\n    tests.push(createGrammarScopeConstraint(grammarScope))\n  }\n  if (pathRegex) {\n    tests.push(createPathRegexConstraint(pathRegex))\n  }\n  if (rootNs) {\n    tests.push(createRootNsConstraint(rootNs))\n  }\n  if (rootLocalName) {\n    tests.push(createRootLocalNameConstraint(rootLocalName))\n  }\n  if (rootAttributes) {\n    for (const name of Object.keys(rootAttributes)) {\n      tests.push(createRootAttributeConstraint(name, rootAttributes[name]))\n    }\n  }\n  if (publicId) {\n    tests.push(createPublicIdConstraint(publicId))\n  }\n\n  // rules without any constraints shall never match\n  if (tests.length === 0) {\n    return () => false\n  }\n\n  return (documentProps) => {\n    return tests.every((test) => test(documentProps))\n  }\n}\n\n/**\n * Sorts rules by `priority` in descending order.\n */\nconst sortByPriority = (rules: Array<Rule>): Array<Rule> =>\n  rules.sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0))\n\n/**\n * Converts the data of a rule's `test` property into a `matches()` function.\n */\nconst createRuleWithMatcher = (rule: Rule): RuleWithMatcher => {\n  return {\n    matches: createDocumentPropsMatcher(rule.test),\n    outcome: rule.outcome,\n  }\n}\n\n/**\n * Stores rules obtained from Atom's user config and other Atom packages.\n */\nexport default class RuleStore {\n  private configRules: Array<RuleWithMatcher> = []\n  private packageRules: Array<RuleWithMatcher> = []\n  private allRules: Array<RuleWithMatcher> = []\n\n  /**\n   * Sets rules from Atom's user config.\n   */\n  public setConfigRules(rules: Array<Rule>) {\n    this.configRules = sortByPriority(rules).map(createRuleWithMatcher)\n    this.allRules = this.configRules.concat(this.packageRules)\n  }\n\n  /**\n   * Sets rules from other Atom packages.\n   */\n  public setPackageRules(rules: Array<Rule>) {\n    this.packageRules = sortByPriority(rules).map(createRuleWithMatcher)\n    this.allRules = this.configRules.concat(this.packageRules)\n  }\n\n  /**\n   * Returns an array of all rules.\n   */\n  public getAll(): Array<RuleWithMatcher> {\n    return this.allRules\n  }\n\n  /**\n   * Returns the outcome of the first rule matching the properties of an\n   * XML document.\n   */\n  public getMatchingOutcome(\n    documentProps: DocumentProps\n  ): RuleOutcome | undefined {\n    const matchingRule = this.allRules.find((rule) =>\n      rule.matches(documentProps)\n    )\n\n    return matchingRule?.outcome\n  }\n}\n","export const showWarningNotification = (message: string, detail: string) => {\n  atom.notifications.addWarning(`[linter-autocomplete-jing] ${message}`, {\n    detail,\n    dismissable: true,\n  })\n}\n\nexport const showErrorNotification = (err: Error) => {\n  atom.notifications.addError(`[linter-autocomplete-jing] ${err.message}`, {\n    detail: err.stack,\n    dismissable: true,\n  })\n}\n","import { TextEditor } from 'atom'\n\nimport {\n  LinterMessage,\n  ParserConfig,\n  SchemaPropsWithLine,\n} from '../getParserConfig'\nimport generateRange from '../util/generateRange'\nimport { RawValidationMessage } from '../xmlService/XmlService'\n\nexport interface ValidationConfig {\n  displaySchemaWarnings: boolean\n}\n\n/**\n * Creates a LinterMessage from message data referring to the current\n * XML document.\n */\nconst createCurrentDocumentLinterMessage = (\n  rawValidationMessage: RawValidationMessage,\n  filePath: string,\n  textEditor: TextEditor\n): LinterMessage => {\n  return {\n    severity:\n      rawValidationMessage.level === 'warning'\n        ? rawValidationMessage.level\n        : 'error',\n    excerpt:\n      rawValidationMessage.lang === 'none'\n        ? rawValidationMessage.text\n        : `${\n            rawValidationMessage.text\n          } [${rawValidationMessage.lang.toUpperCase()}]`,\n    location: {\n      file: filePath,\n      position: generateRange(textEditor, rawValidationMessage.line - 1),\n    },\n  }\n}\n\n/**\n * Creates a LinterMessage from message data referring to an external entity.\n * The message is relocated to the current XML document: When the entity is a\n * schema referenced from the current XML document, locates it at the schema\n * reference in the current XML document, otherwise puts it to the start of the\n * current XML document.\n */\nconst createExternalEntityLinterMessage = (\n  rawValidationMessage: RawValidationMessage,\n  filePath: string | undefined,\n  textEditor: TextEditor,\n  schemaProps: Array<SchemaPropsWithLine>\n): LinterMessage | null => {\n  const label =\n    rawValidationMessage.level === 'warning'\n      ? 'Schema parser warning: '\n      : 'Could not process schema or catalog: '\n\n  const schema = schemaProps.find(\n    (sch) =>\n      sch.path === rawValidationMessage.systemId &&\n      sch.lang === rawValidationMessage.lang\n  )\n\n  return {\n    severity: 'warning',\n    excerpt: label + rawValidationMessage.text,\n    location: {\n      file: filePath,\n      // when the path of the external entity matches a schema in the current\n      // XML document, locate the message where the schema is referenced;\n      // otherwise locate it at the start\n      position: schema\n        ? generateRange(textEditor, schema.lineOfReference)\n        : [\n            [0, 0],\n            [0, 0],\n          ],\n    },\n  }\n}\n\n/**\n * Creates linter messages from the response of a validation request to the\n * Java server.\n */\nconst createLinterMessages = (\n  rawValidationMessages: Array<RawValidationMessage | null>,\n  textEditor: TextEditor,\n  validationConfig: ValidationConfig,\n  parserConfig: ParserConfig\n): Array<LinterMessage> => {\n  const messages = rawValidationMessages\n    .map((rawValidationMessage: RawValidationMessage | null) => {\n      if (!rawValidationMessage) return null\n\n      const filePath = textEditor.getPath()\n\n      if (rawValidationMessage.systemId !== filePath) {\n        // message refers to an external entity\n\n        if (\n          !validationConfig.displaySchemaWarnings &&\n          rawValidationMessage.level === 'warning'\n        ) {\n          // exclude warnings referring to external entities when\n          // `displaySchemaWarnings` in the user config isn't `true`\n          return null\n        }\n\n        return createExternalEntityLinterMessage(\n          rawValidationMessage,\n          filePath,\n          textEditor,\n          parserConfig.schemaProps\n        )\n      }\n\n      // message refers to current XML document\n      return createCurrentDocumentLinterMessage(\n        rawValidationMessage,\n        filePath,\n        textEditor\n      )\n    })\n    .filter((message) => !!message)\n\n  return messages as Array<LinterMessage>\n}\n\nexport default createLinterMessages\n","import { Socket } from 'net'\n\n/**\n * Sends a socket request to the Java server on the specified port and returns\n * the response.\n */\nexport const request = (\n  port: number,\n  headers: Array<string | number>,\n  body: string | null\n): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    let response = ''\n\n    const socket = new Socket()\n\n    socket.on('connect', () => {\n      socket.write(headers.map((header) => `-${header}\\n`).join(''))\n\n      if (body !== null) {\n        socket.write('\\n')\n        socket.write(body)\n      }\n\n      socket.end()\n    })\n\n    socket.on('data', (data) => {\n      response += data.toString()\n    })\n\n    socket.on('close', () => {\n      resolve(response)\n    })\n\n    socket.on('error', (err) => {\n      socket.destroy()\n      reject(err)\n    })\n\n    socket.connect({ port })\n  })\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n","var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n","const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = require('path')\nconst COLON = isWindows ? ';' : ':'\nconst isexe = require('isexe')\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n","'use strict';\n\nconst pathKey = (options = {}) => {\n\tconst environment = options.env || process.env;\n\tconst platform = options.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n};\n\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n","'use strict';\n\nconst path = require('path');\nconst which = require('which');\nconst getPathKey = require('path-key');\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({ env })],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        if (shouldSwitchCwd) {\n            process.chdir(cwd);\n        }\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n","'use strict';\n\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    return arg;\n}\n\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n\n    // Algorithm below is based on https://qntm.org/cmd\n\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) {\n        arg = arg.replace(metaCharsRegExp, '^$1');\n    }\n\n    return arg;\n}\n\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n","'use strict';\nmodule.exports = /^#!(.*)/;\n","'use strict';\n\nconst fs = require('fs');\nconst shebangCommand = require('shebang-command');\n\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n\n    let fd;\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* Empty */ }\n\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\n\nmodule.exports = readShebang;\n","'use strict';\nconst shebangRegex = require('shebang-regex');\n\nmodule.exports = (string = '') => {\n\tconst match = string.match(shebangRegex);\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tconst [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n\tconst binary = path.split('/').pop();\n\n\tif (binary === 'env') {\n\t\treturn argument;\n\t}\n\n\treturn argument ? `${binary} ${argument}` : binary;\n};\n","'use strict';\n\nconst path = require('path');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n","'use strict';\n\nconst isWin = process.platform === 'win32';\n\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args,\n    });\n}\n\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) {\n        return;\n    }\n\n    const originalEmit = cp.emit;\n\n    cp.emit = function (name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed, 'spawn');\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\n\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawn');\n    }\n\n    return null;\n}\n\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawnSync');\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError,\n};\n","'use strict';\n\nconst cp = require('child_process');\nconst parse = require('./lib/parse');\nconst enoent = require('./lib/enoent');\n\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n\n    return result;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\n\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n","import { ChildProcess } from 'child_process'\nimport path from 'path'\n\nimport spawn from 'cross-spawn'\n\nimport logError from '../util/logError'\nimport { showErrorNotification } from '../util/notifications'\n\nconst jarPath = '../vendor/xml-tools-server-0.4.8.jar'\n\n/**\n * Global server configuration.\n */\nexport interface ServerConfig {\n  jvmArguments: string\n  javaExecutablePath: string\n  schemaCacheSize: number\n}\n\nclass ServerProcessError extends Error {\n  constructor(message: string, cause?: Error) {\n    super(message)\n    this.name = 'ServerProcessError'\n    if (cause) {\n      this.stack = cause.stack\n    }\n  }\n}\n\nenum State {\n  STOPPED,\n  INITIALIZING,\n  READY,\n}\n\n/**\n * Manages startup and shutdown of the Java server process.\n */\nexport default class ServerProcessManager {\n  private state: State = State.STOPPED\n\n  /**\n   * A promise resolving with the Java server's port once server\n   * startup is complete. `null` when the server has been shut down\n   * or server startup hasn't been triggered yet.\n   */\n  private portPromise: Promise<number> | null = null\n  private javaProcess: ChildProcess | null = null\n\n  public isStopped() {\n    return this.state === State.INITIALIZING\n  }\n\n  /**\n   * Returns a promise resolving with the server's port if server startup is\n   * complete.\n   */\n  public async getPortIfReadyNow() {\n    if (this.state !== State.READY) return null\n\n    return this.portPromise\n  }\n\n  /**\n   * Returns a promise resolving with the server's port if server startup has\n   * already been triggered.\n   */\n  public async getPortIfStartupTriggered() {\n    return this.portPromise\n  }\n\n  /**\n   * Returns a promise resolving with the server's port. If server startup\n   * hasn't been triggered yet or the server has been shut down, a new server\n   * process gets started.\n   */\n  public ensurePort(config: ServerConfig) {\n    if (!this.portPromise) {\n      this.portPromise = this.startup(config)\n    }\n    return this.portPromise\n  }\n\n  public shutdown() {\n    this.state = State.STOPPED\n    if (this.javaProcess) {\n      this.removeListeners(this.javaProcess)\n      this.javaProcess.kill()\n      this.javaProcess = null\n    }\n    this.portPromise = null\n  }\n\n  /**\n   * Starts the Java server process and returns a promise resolving with the\n   * port of the Java server.\n   */\n  private async startup(config: ServerConfig) {\n    this.state = State.INITIALIZING\n\n    try {\n      const args = [\n        ...config.jvmArguments.split(/\\s+/),\n        '-jar',\n        path.resolve(__dirname, jarPath),\n        '0', // initial port\n        String(config.schemaCacheSize),\n      ]\n      this.javaProcess = spawn(config.javaExecutablePath, args, {})\n\n      const port = await this.waitForPort(\n        config.javaExecutablePath,\n        this.javaProcess\n      )\n\n      this.removeListeners(this.javaProcess)\n      this.setDefaultListeners(this.javaProcess)\n\n      this.state = State.READY\n\n      return port\n    } catch (err) {\n      this.shutdown()\n      throw err\n    }\n  }\n\n  /**\n   * Returns a Promise resolving with the Java server's port. The port is read\n   * from the server's startup message on the standard output stream. If the\n   * port couldn't get determined, if data arrives on the standard error stream\n   * or if the process emits an error event, the Promise gets rejected.\n   */\n  private waitForPort(\n    javaExecutablePath: string,\n    javaProcess: ChildProcess\n  ): Promise<number> {\n    return new Promise((resolve, reject) => {\n      if (!javaProcess.stdout || !javaProcess.stderr) {\n        return reject(\n          new ServerProcessError(\n            'Configuration error: the Java child process must provide standard streams'\n          )\n        )\n      }\n\n      javaProcess.stdout.on('data', (data: Buffer) => {\n        const match = data\n          .toString()\n          .match(/XML Tools Server listening on port (\\d+)/)\n        if (match) {\n          const port = Number(match[1])\n          resolve(port)\n        } else {\n          reject(\n            new ServerProcessError(\n              `Unexpected message on server startup: \"${data}\"`\n            )\n          )\n        }\n      })\n\n      javaProcess.stderr.on('data', (data: Buffer) => {\n        reject(\n          new ServerProcessError(\n            `Unexpected error on server startup: \"${data}\"`\n          )\n        )\n      })\n\n      javaProcess.on('error', (err: Error) => {\n        reject(\n          new ServerProcessError(\n            'Failed to run Java server. Please make sure Java is installed ' +\n              'and can be run with the Java executable path in the ' +\n              '\"linter-autocomplete-jing\" package settings ' +\n              `(\"${javaExecutablePath}\").`,\n            err\n          )\n        )\n      })\n    })\n  }\n\n  private setDefaultListeners(javaProcess: ChildProcess) {\n    javaProcess.stderr?.on('data', (data) => {\n      logError(`Server message on standard error stream: \"${data}\"`)\n    })\n\n    javaProcess.on('error', (err) => {\n      showErrorNotification(err)\n      this.shutdown()\n    })\n  }\n\n  private removeListeners(javaProcess: ChildProcess) {\n    javaProcess.stdout?.removeAllListeners('data')\n    javaProcess.stderr?.removeAllListeners('data')\n    javaProcess.removeAllListeners('error')\n  }\n}\n","import { ParserConfig, SchemaPropsWithLine } from '../getParserConfig'\n\nexport interface AutocompleteConfig {\n  autocompletePriority: number\n  autocompleteScope: {\n    rng: boolean\n    rnc: boolean\n    xsd: boolean\n  }\n  wildcardSuggestions: 'none' | 'localparts' | 'all'\n}\n\nexport interface SuggestionOptions {\n  type: 'N' | 'V' | 'E'\n  attName?: string\n  tagEndDelimiterBufferIndex?: number\n}\n\nexport const buildValidationRequestHeaders = (\n  parserConfig: ParserConfig\n): Array<string> => {\n  const {\n    filePath,\n    schemaProps,\n    xmlCatalog,\n    xIncludeAware,\n    xIncludeFixupBaseUris,\n    xIncludeFixupLanguage,\n  } = parserConfig\n\n  const parserFlags = [\n    'r',\n    xIncludeAware ? 'x' : '',\n    xIncludeFixupBaseUris ? 'f' : '',\n    xIncludeFixupLanguage ? 'l' : '',\n  ].join('')\n\n  return [\n    'V',\n    parserFlags,\n    'UTF-8',\n    filePath ?? '',\n    xmlCatalog ?? '',\n    ...schemaProps.map((schema) => schema.lang + ' ' + (schema.path || '')),\n  ]\n}\n\n/**\n * Determines which schema to use to get the Autocomplete suggestions based\n * on the schema information from the document and the user settings in\n * `autocompleteConfig.autocompleteScope`\n */\nexport const getSchemaForSuggestions = (\n  autocompleteConfig: AutocompleteConfig,\n  schemaProps: Array<SchemaPropsWithLine>\n): SchemaPropsWithLine => {\n  const schema = schemaProps.find(({ lang }) => {\n    if (lang === 'rng' || lang === 'rnc' || lang === 'xsd') {\n      return autocompleteConfig.autocompleteScope[lang]\n    }\n    return false\n  })\n\n  return (\n    schema || {\n      lang: 'none',\n      path: null,\n    }\n  )\n}\n\nconst wildcardFlags = {\n  none: '',\n  localparts: 'w',\n  all: 'wn',\n}\n\nexport const buildAutocompleteRequestHeaders = (\n  parserConfig: ParserConfig,\n  autocompleteConfig: AutocompleteConfig,\n  suggestionOptions: SuggestionOptions\n): Array<string | number> => {\n  const {\n    schemaProps,\n    filePath,\n    xmlCatalog,\n    xIncludeAware,\n    xIncludeFixupBaseUris,\n    xIncludeFixupLanguage,\n  } = parserConfig\n\n  const schema = getSchemaForSuggestions(autocompleteConfig, schemaProps)\n\n  const { type, attName, tagEndDelimiterBufferIndex } = suggestionOptions\n\n  const parserFlags = [\n    'r',\n    wildcardFlags[autocompleteConfig.wildcardSuggestions],\n    xIncludeAware ? 'x' : '',\n    xIncludeFixupBaseUris ? 'f' : '',\n    xIncludeFixupLanguage ? 'l' : '',\n  ].join('')\n\n  return [\n    'A',\n    type,\n    attName || '',\n    tagEndDelimiterBufferIndex || '',\n    parserFlags,\n    'UTF-8',\n    filePath ?? 'undefined',\n    xmlCatalog || '',\n    schema.lang + ' ' + (schema.path || ''),\n  ]\n}\n","import { ParserConfig } from '../getParserConfig'\nimport logError from '../util/logError'\nimport { showErrorNotification } from '../util/notifications'\nimport { request } from './client'\nimport ServerProcessManager, { ServerConfig } from './ServerProcessManager'\nimport {\n  AutocompleteConfig,\n  SuggestionOptions,\n  buildAutocompleteRequestHeaders,\n  buildValidationRequestHeaders,\n} from './util'\n\nexport interface RawSuggestion {\n  value: string\n  documentation?: Array<string>\n  listItem?: boolean\n  empty?: boolean\n  closing?: boolean\n  attributes?: Array<string>\n}\n\nexport interface RawValidationMessage {\n  lang: string\n  systemId: string\n  line: number\n  level: string\n  text: string\n}\n\nconst validationMessageRegex = /^([a-z0-9.]+?):((.*?):\\s?)?((\\d+):)?(?:\\d+:\\s)?(error|fatal|warning):\\s(.*)$/\n\n/**\n * Extracts message data from a plain-text Java error/warning.\n */\nconst getRawValidationMessage = (str: string): RawValidationMessage | null => {\n  const match = validationMessageRegex.exec(str)\n  if (!match) {\n    logError(`Could not parse message \"${str}\"`)\n    return null\n  }\n\n  const [, lang, , systemId, , line, level, text] = match\n\n  return {\n    lang,\n    systemId,\n    line: Number(line),\n    level,\n    text,\n  }\n}\n\n/**\n * Provides an interface to request validation and autocomplete suggestions\n * from the Java server and handles its configuration and lifetime.\n */\nexport default class XmlService {\n  private readonly serverProcessManager: ServerProcessManager\n\n  private config: ServerConfig = {\n    jvmArguments: '-Xms32m -Xmx256m',\n    javaExecutablePath: 'java',\n    schemaCacheSize: 10,\n  }\n\n  constructor(serverProcessManager?: ServerProcessManager) {\n    this.serverProcessManager =\n      serverProcessManager || new ServerProcessManager()\n  }\n\n  public async requestValidation(\n    parserConfig: ParserConfig,\n    body: string | null\n  ): Promise<Array<RawValidationMessage | null>> {\n    const port = await this.serverProcessManager.ensurePort(this.config)\n    const headers = buildValidationRequestHeaders(parserConfig)\n\n    const response = await request(port, headers, body)\n\n    const messages = response\n      .trim()\n      .split(/\\r?\\n/)\n      .map((responseLine: string) => {\n        if (!responseLine) return null\n\n        return getRawValidationMessage(responseLine)\n      })\n\n    return messages\n  }\n\n  public async requestAutocompleteSuggestions(\n    parserConfig: ParserConfig,\n    autocompleteConfig: AutocompleteConfig,\n    suggestionOptions: SuggestionOptions,\n    body: string | null\n  ): Promise<Array<RawSuggestion>> {\n    const port = await this.serverProcessManager.ensurePort(this.config)\n    const headers = buildAutocompleteRequestHeaders(\n      parserConfig,\n      autocompleteConfig,\n      suggestionOptions\n    )\n\n    try {\n      const response = await request(port, headers, body)\n\n      const rawSuggestions = JSON.parse(response)\n\n      return rawSuggestions\n    } catch (err) {\n      logError('Error requesting suggestions', err)\n      return []\n    }\n  }\n\n  public setJavaExecutablePath(javaExecutablePath: string) {\n    if (this.config.javaExecutablePath === javaExecutablePath) return\n\n    this.config.javaExecutablePath = javaExecutablePath\n\n    // `javaExecutablePath` gets read when the server process starts; in order\n    // to update these settings, we shut down the process here so it will get\n    // restarted with the new settings on the next call of\n    // `ServerProcessManager.ensurePort()`\n    if (!this.serverProcessManager.isStopped()) {\n      this.serverProcessManager.shutdown()\n    }\n  }\n\n  public setJvmArguments(jvmArguments: string) {\n    if (this.config.jvmArguments === jvmArguments) return\n\n    this.config.jvmArguments = jvmArguments\n\n    // `jvmArguments` gets read when the server process starts; in order\n    // to update these settings, we shut down the process here so it will get\n    // restarted with the new settings on the next call of\n    // `ServerProcessManager.ensurePort()`\n    if (!this.serverProcessManager.isStopped()) {\n      this.serverProcessManager.shutdown()\n    }\n  }\n\n  public async setSchemaCacheSize(schemaCacheSize: number) {\n    if (this.config.schemaCacheSize === schemaCacheSize) return\n\n    this.config.schemaCacheSize = schemaCacheSize\n\n    try {\n      const port = await this.serverProcessManager.getPortIfStartupTriggered()\n\n      // We only need to send a request to the server to update\n      // `schemaCacheSize` when server startup has already been triggered. If\n      // not, then the server will receive the latest value of `schemaCacheSize`\n      // on the next call of `ServerProcessManager.ensurePort()`\n      if (port === null) return\n\n      await request(port, ['S', schemaCacheSize], null)\n    } catch (err) {\n      showErrorNotification(err)\n    }\n  }\n\n  public async clearSchemaCache() {\n    try {\n      const port = await this.serverProcessManager.getPortIfReadyNow()\n\n      // the server's schema cache is initially empty so there's no need to\n      // clear it when the server is not yet ready to process requests\n      if (port === null) return\n\n      await request(port, ['C'], null)\n    } catch (err) {\n      showErrorNotification(err)\n    }\n  }\n\n  public shutdown() {\n    this.serverProcessManager.shutdown()\n  }\n}\n","import { CompositeDisposable, TextEditor } from 'atom'\n\nimport suggest from './autocomplete/suggest'\nimport { AutocompleteContext, Suggestion } from './autocomplete/util'\nimport getParserConfig, {\n  DefaultParserConfig,\n  LinterMessage,\n} from './getParserConfig'\nimport getRulesFromAtomPackages from './rules/getRulesFromAtomPackages'\nimport RuleStore, { Rule } from './rules/RuleStore'\nimport validateRules from './rules/validateRules'\nimport {\n  showErrorNotification,\n  showWarningNotification,\n} from './util/notifications'\nimport { ValidationConfig } from './validation/createLinterMessages'\nimport validate from './validation/validate'\nimport { AutocompleteConfig } from './xmlService/util'\nimport XmlService from './xmlService/XmlService'\n\nlet subscriptions = new CompositeDisposable()\n\nexport const xmlService = new XmlService()\n\nconst ruleStore = new RuleStore()\n\n/**\n * The grammar scopes our Linter provider should be invoked on.\n */\nconst grammarScopes: Array<string> = []\n\nconst defaultParserConfig: DefaultParserConfig = {\n  xmlCatalog: '',\n  dtdValidation: 'fallback',\n  xIncludeAware: true,\n  xIncludeFixupBaseUris: true,\n  xIncludeFixupLanguage: true,\n}\n\nconst validationConfig: ValidationConfig = {\n  displaySchemaWarnings: false,\n}\n\nconst autocompleteConfig: AutocompleteConfig = {\n  wildcardSuggestions: 'none',\n  autocompletePriority: 1,\n  autocompleteScope: {\n    rnc: true,\n    rng: true,\n    xsd: true,\n  },\n}\n\n// ******************* ATOM HOOKS, EVENTS AND COMMANDS *********************\n\nconst handlePackageChanges = () => {\n  const newGrammarScopes = atom.grammars\n    .getGrammars()\n    .map((grammar) => grammar.scopeName)\n    .filter((scopeName) => scopeName?.startsWith('text.xml'))\n\n  // `grammarScopes` gets passed to the linter when the initial\n  // `provideLinter()` function is called and gets stored there. In order\n  // to propagate changes to the content of `grammarScopes` to the linter,\n  // we need to mutate it\n  grammarScopes.splice(0, grammarScopes.length, ...newGrammarScopes)\n\n  const packages = atom.packages.getActivePackages()\n  const packageRules = getRulesFromAtomPackages(packages)\n  ruleStore.setPackageRules(packageRules)\n}\n\n/**\n * Activation hook, called by Atom when the `linter-autocomplete-jing`\n * package is activated\n */\nexport function activate() {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  require('atom-package-deps').install('linter-autocomplete-jing')\n\n  subscriptions = new CompositeDisposable()\n\n  subscriptions.add(\n    atom.config.observe(`linter-autocomplete-jing.rules`, (rules: unknown) => {\n      if (Array.isArray(rules)) {\n        try {\n          validateRules(rules)\n        } catch (err) {\n          showWarningNotification(\n            `Could not set rules from user config: ${err.message}`,\n            JSON.stringify(rules, null, 2)\n          )\n          return\n        }\n        ruleStore.setConfigRules(rules as Array<Rule>)\n      }\n    })\n  )\n\n  subscriptions.add(\n    atom.config.observe(\n      `linter-autocomplete-jing.jvmArguments`,\n      (jvmArguments: string) => xmlService.setJvmArguments(jvmArguments)\n    )\n  )\n\n  subscriptions.add(\n    atom.config.observe(\n      `linter-autocomplete-jing.javaExecutablePath`,\n      (javaExecutablePath: string) =>\n        xmlService.setJavaExecutablePath(javaExecutablePath)\n    )\n  )\n\n  subscriptions.add(\n    atom.config.observe(\n      `linter-autocomplete-jing.schemaCacheSize`,\n      (schemaCacheSize: number) =>\n        xmlService.setSchemaCacheSize(schemaCacheSize)\n    )\n  )\n  ;(Object.keys(defaultParserConfig) as Array<\n    keyof DefaultParserConfig\n  >).forEach(\n    <K extends keyof DefaultParserConfig, V extends DefaultParserConfig[K]>(\n      key: K\n    ) =>\n      subscriptions.add(\n        atom.config.observe(`linter-autocomplete-jing.${key}`, (value: V) => {\n          defaultParserConfig[key] = value\n        })\n      )\n  )\n\n  subscriptions.add(\n    atom.config.observe(\n      `linter-autocomplete-jing.displaySchemaWarnings`,\n      (displaySchemaWarnings: boolean) => {\n        validationConfig.displaySchemaWarnings = displaySchemaWarnings\n      }\n    )\n  )\n  ;(Object.keys(autocompleteConfig) as Array<keyof AutocompleteConfig>).forEach(\n    <K extends keyof AutocompleteConfig, V extends AutocompleteConfig[K]>(\n      key: K\n    ) =>\n      subscriptions.add(\n        atom.config.observe(`linter-autocomplete-jing.${key}`, (value: V) => {\n          autocompleteConfig[key] = value\n        })\n      )\n  )\n\n  subscriptions.add(\n    atom.commands.add('atom-workspace', {\n      'linter-autocomplete-jing:clear-schema-cache': () =>\n        xmlService.clearSchemaCache(),\n    })\n  )\n\n  const setPackageChangeListeners = () => {\n    subscriptions.add(atom.packages.onDidActivatePackage(handlePackageChanges))\n    subscriptions.add(\n      atom.packages.onDidDeactivatePackage(handlePackageChanges)\n    )\n  }\n\n  // if the inital Atom packages haven't all been activated yet,\n  // defer handling package changes until all packages have been\n  // activated\n  if (!atom.packages.hasActivatedInitialPackages()) {\n    subscriptions.add(\n      atom.packages.onDidActivateInitialPackages(() => {\n        handlePackageChanges()\n        setPackageChangeListeners()\n      })\n    )\n  } else {\n    handlePackageChanges()\n    setPackageChangeListeners()\n  }\n}\n\n/**\n * Deactivation hook, called by Atom when the `linter-autocomplete-jing`\n * package is deactivated.\n */\nexport function deactivate() {\n  subscriptions.dispose()\n  xmlService.shutdown()\n}\n\n// ********************************* LINTER **********************************\n\n/**\n * Exposes the `linter-autocomplete-jing` linter provider to the linter service.\n */\nexport function provideLinter() {\n  return {\n    name: 'Jing',\n    grammarScopes,\n    scope: 'file',\n    lintsOnChange: true,\n\n    async lint(textEditor: TextEditor): Promise<Array<LinterMessage> | null> {\n      if (!textEditor.getPath()) return null\n\n      try {\n        const { parserConfig, xmlModelWarnings } = getParserConfig(\n          textEditor,\n          ruleStore,\n          defaultParserConfig\n        )\n\n        const messages = await validate(\n          textEditor,\n          validationConfig,\n          parserConfig,\n          xmlService\n        )\n\n        return messages.concat(xmlModelWarnings).sort((a, b) => {\n          return a.location.position[0][0] - b.location.position[0][0]\n        })\n      } catch (err) {\n        showErrorNotification(err)\n        return []\n      }\n    },\n  }\n}\n\n// ****************************** AUTOCOMPLETE ********************************\n\nconst triggerAutocomplete = (editor: TextEditor) => {\n  ;(atom.commands.dispatch as (\n    target: Node,\n    commandName: string,\n    // The `options` parameter is not part of the official Atom API but gets\n    // forwarded to Autocomplete Plus and processed there\n    options: { activatedManually: boolean }\n  ) => Promise<void> | null)(\n    atom.views.getView(editor),\n    'autocomplete-plus:activate',\n    {\n      activatedManually: false,\n    }\n  )\n}\n\n/**\n * Indicates whether the next call of `getSuggestions()` should get canceled.\n */\nlet cancelNextAutocomplete = false\n\n/**\n * Exposes the `linter-autocomplete-jing` autocomplete provider to the\n * `autocomplete plus` service.\n */\nexport function provideAutocomplete() {\n  return {\n    selector: '.text.xml',\n    disableForSelector: '.comment, .string.unquoted.cdata.xml',\n    inclusionPriority: autocompleteConfig.autocompletePriority,\n    excludeLowerPriority: true,\n\n    async getSuggestions(\n      ctx: AutocompleteContext\n    ): Promise<Array<Suggestion> | null> {\n      if (cancelNextAutocomplete) {\n        atom.commands.dispatch(\n          atom.views.getView(ctx.editor),\n          'autocomplete-plus:cancel'\n        )\n        cancelNextAutocomplete = false\n\n        return null\n      }\n\n      try {\n        const { parserConfig } = getParserConfig(\n          ctx.editor,\n          ruleStore,\n          defaultParserConfig\n        )\n\n        return suggest(ctx, autocompleteConfig, parserConfig, xmlService)\n      } catch (err) {\n        showErrorNotification(err)\n        return []\n      }\n    },\n\n    onDidInsertSuggestion({\n      editor,\n      suggestion,\n    }: {\n      editor: TextEditor\n      suggestion: Suggestion\n    }) {\n      if (suggestion.retrigger) {\n        // When a suggestion has `retrigger` set to `true` (which, for example,\n        // is the case when an element suggestion with new attributes got\n        // inserted), trigger autocomplete (in this case, on the value of the\n        // first new attribute).\n\n        setTimeout(() => triggerAutocomplete(editor), 1)\n      } else {\n        // Exit early from any call of `getSuggestions()` within the next 300ms.\n        // This prevents surplus suggestion dialogs appearing immediately after\n        // the insertion of a plain element or attribute name.\n\n        cancelNextAutocomplete = true\n        setTimeout(() => {\n          cancelNextAutocomplete = false\n        }, 300)\n      }\n    },\n  }\n}\n","import { TextEditor } from 'atom'\n\nimport { LinterMessage, ParserConfig } from '../getParserConfig'\nimport XmlService from '../xmlService/XmlService'\nimport createLinterMessages, { ValidationConfig } from './createLinterMessages'\n\n/**\n * Requests validation of the current XML document from the XMLService and\n * transforms the response into linter messages.\n */\nconst validate = async (\n  textEditor: TextEditor,\n  validationConfig: ValidationConfig,\n  parserConfig: ParserConfig,\n  xmlService: XmlService\n): Promise<Array<LinterMessage>> => {\n  const rawValidationMessages = await xmlService.requestValidation(\n    parserConfig,\n    textEditor.getText()\n  )\n\n  const messages = createLinterMessages(\n    rawValidationMessages,\n    textEditor,\n    validationConfig,\n    parserConfig\n  )\n\n  return messages\n}\n\nexport default validate\n"],"names":["precedingAttValueOrTagDelimiterRegex","nextAttValueOrTagDelimiterRegex","getNextTagEndDelimiterPosition","editor","bufferPosition","position","scanInBufferRange","getBuffer","getEndPosition","matchText","range","stop","startsWith","start","row","column","length","createAttributeSuggestionTexts","attNameWithNs","tabstopMarkerId","suggestAttributeValue","qName","nsUri","split","nsPrefix","attNameSnippet","replace","nsUriSnippet","snippet","displayText","nameStartChar","join","nameChar","trailingAttNameStartRegex","RegExp","leadingAttributeRegex","getAttributeNameSuggestions","async","ctx","autocompleteConfig","parserConfig","xmlService","textPrecedingCursorInSameLine","attNameFragmentPrecedingCursor","str","match","getTrailingAttNameFragment","tagEndDelimiterPosition","documentTextPrecedingAttNameFragment","getTextInBufferRange","documentTextFromCursorToTagEndDelimiter","leadingAttributeMatch","body","substr","rawSuggestions","filter","rawSuggestion","value","map","documentation","type","replacementPrefix","description","undefined","retrigger","createAttributeNameSuggestions","requestAutocompleteSuggestions","trailingTokenRegex","getBufferIndex","documentTextPrecedingPosition","Buffer","byteLength","attNameAndValueDoubleQuoteRegex","attNameAndValueSingleQuoteRegex","escape","replacements","regex","Object","keys","escapeWithSingleQuotes","&","<","'","escapeWithDblQuotes","\"","createAttributeValueSuggestions","valueFragmentPrecedingCursor","hasDblQuotes","trailingTokenInValueFragment","getTrailingToken","listItem","rightLabel","getAttributeValueSuggestions","currentAttribute","result","backwardsScanInBufferRange","name","getAttributeNameAndValuePrecedingCursor","getText","attName","tagEndDelimiterBufferIndex","rawStaticMarkupSuggestions","createMarkupSuggestions","markupFragmentPrecedingCursor","suggestOnlyTagName","concat","closing","createStaticMarkupSuggestion","createEndTagSuggestion","empty","attributes","tagName","tagNameSnippet","hasTabstopMarkerInTagName","nsSnippet","attributeSnippets","attribute","attributeSnippet","newTabstopMarkerId","startTagContent","createStartTagSuggestion","getMarkupSuggestions","nextTagDelimiterIsEndDelimiter","trailingMarkupRegex","suggest","getTextPrecedingCursorInSameLine","getTrailingMarkupFragment","scopes","scopeDescriptor","getScopesArray","some","item","hasTagScope","quotedScope","find","scope","getQuotedScope","precedingTagDelimiterIsStartTagStartDelimiter","Promise","resolve","sax","parser","strict","opt","SAXParser","SAXStream","createStream","MAX_BUFFER_LENGTH","Stream","buffers","this","i","l","clearBuffers","q","c","bufferCheckPosition","lowercase","lowercasetags","looseCase","tags","closed","closedRoot","sawRoot","tag","error","noscript","state","S","BEGIN","strictEntities","ENTITIES","create","XML_ENTITIES","attribList","xmlns","ns","rootNS","trackPosition","line","emit","EVENTS","o","F","prototype","a","hasOwnProperty","push","end","write","chunk","toString","charAt","BEGIN_WHITESPACE","beginWhiteSpace","TEXT","starti","textNode","substring","isWhitespace","strictFail","TEXT_ENTITY","OPEN_WAKA","startTagPosition","SCRIPT","SCRIPT_ENDING","script","CLOSE_TAG","SGML_DECL","sgmlDecl","isMatch","nameStart","OPEN_TAG","PROC_INST","procInstName","procInstBody","pad","Array","toUpperCase","emitNode","CDATA","cdata","COMMENT","comment","DOCTYPE","doctype","isQuote","SGML_DECL_QUOTED","DOCTYPE_DTD","DOCTYPE_QUOTED","DOCTYPE_DTD_QUOTED","COMMENT_ENDING","COMMENT_ENDED","textopts","CDATA_ENDING","CDATA_ENDING_2","PROC_INST_ENDING","PROC_INST_BODY","nameBody","newTag","openTag","OPEN_TAG_SLASH","ATTRIB","closeTag","attribName","attribValue","ATTRIB_NAME","ATTRIB_VALUE","attrib","ATTRIB_NAME_SAW_WHITE","ATTRIB_VALUE_QUOTED","ATTRIB_VALUE_UNQUOTED","ATTRIB_VALUE_ENTITY_Q","ATTRIB_VALUE_CLOSED","isAttribEnd","ATTRIB_VALUE_ENTITY_U","CLOSE_TAG_SAW_WHITE","notMatch","returnState","buffer","parseEntity","entity","entityBody","entityStart","Error","maxAllowed","Math","max","maxActual","len","closeText","m","checkBufferLength","resume","close","flush","require$$0","ex","streamWraps","ev","apply","_parser","writable","readable","me","onend","onerror","er","_decoder","forEach","defineProperty","get","set","h","removeAllListeners","on","enumerable","configurable","constructor","data","isBuffer","SD","require$$1","StringDecoder","handler","indexOf","args","arguments","splice","call","XML_NAMESPACE","XMLNS_NAMESPACE","xml","test","stringFromCharCode","floor","fromCodePoint","s","STATE","COMMENT_STARTING","amp","gt","lt","quot","apos","AElig","Aacute","Acirc","Agrave","Aring","Atilde","Auml","Ccedil","ETH","Eacute","Ecirc","Egrave","Euml","Iacute","Icirc","Igrave","Iuml","Ntilde","Oacute","Ocirc","Ograve","Oslash","Otilde","Ouml","THORN","Uacute","Ucirc","Ugrave","Uuml","Yacute","aacute","acirc","aelig","agrave","aring","atilde","auml","ccedil","eacute","ecirc","egrave","eth","euml","iacute","icirc","igrave","iuml","ntilde","oacute","ocirc","ograve","oslash","otilde","ouml","szlig","thorn","uacute","ucirc","ugrave","uuml","yacute","yuml","copy","reg","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","ordf","laquo","not","shy","macr","deg","plusmn","sup1","sup2","sup3","acute","micro","para","middot","cedil","ordm","raquo","frac14","frac12","frac34","iquest","times","divide","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","prop","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","key","e","String","fromCharCode","event","nodeType","text","trim","normalize","message","parent","qname","qualName","prefix","local","qn","selfClosing","uri","JSON","stringify","p","nv","isSelfClosing","toLowerCase","t","closeTo","pop","x","n","num","entityLC","numStr","slice","parseInt","isNaN","highSurrogate","lowSurrogate","MAX_SIZE","codeUnits","index","codePoint","Number","isFinite","RangeError","exports","generateRange","textEditor","isEditor","atom","workspace","isTextEditor","validateEditor","lineNumber","lineMax","getLineCount","lineText","lineForRow","colEnd","colStart","indentation","urlRegex","publicIdRegex","getParserConfig","ruleStore","defaults","filePath","getPath","baseUri","path","dirname","__dirname","xmlModelWarnings","schemaProps","xsdSchemaPaths","saxParser","rootNs","rootLocalName","publicId","done","hasDoctype","rootAttributes","addXsdSchemaPath","href","ondoctype","onprocessinginstruction","node","schematypens","piData","pseudoAtts","_","getPseudoAttsFromPIData","extname","severity","excerpt","location","file","lineOfReference","onopentag","rootNsPrefix","localName","colonIndex","splitQName","prefixes","getXsiNamespacePrefixes","noNamespaceSchemaLocation","schemaLocation","textBuffer","lineCount","lineLength","docProps","rootScopes","getRootScopeDescriptor","ruleOutcome","getMatchingOutcome","xmlCatalog","dtdValidation","xIncludeAware","xIncludeFixupBaseUris","xIncludeFixupLanguage","logError","console","isArray","isObject","obj","isString","validateRule","rule","priority","outcome","grammarScope","pathRegex","validateRules","rules","err","resolvePaths","baseDir","newOutcome","schemaPath","getRulesFromAtomPackages","packages","reduce","pkg","settings","getSettingsFiles","settingsPath","properties","validation","settingsDir","newRules","createRootAttributeConstraint","createDocumentPropsMatcher","tests","includes","pattern","createPathRegexConstraint","createRootNsConstraint","createRootLocalNameConstraint","createPublicIdConstraint","documentProps","every","sortByPriority","sort","b","createRuleWithMatcher","matches","showErrorNotification","notifications","addError","detail","stack","dismissable","createLinterMessages","rawValidationMessages","validationConfig","rawValidationMessage","systemId","displaySchemaWarnings","level","label","schema","sch","createExternalEntityLinterMessage","createCurrentDocumentLinterMessage","request","port","headers","reject","response","socket","Socket","header","destroy","connect","isexe","checkStat","stat","options","isSymbolicLink","isFile","pathext","pathExt","process","env","PATHEXT","checkPathExt","cb","fs","sync","statSync","core","mod","mode","uid","gid","myUid","getuid","myGid","getgid","u","g","ug","checkMode","platform","global","TESTING_WINDOWS","TypeError","is","code","ignoreErrors","isWindows","OSTYPE","COLON","getNotFoundError","cmd","assign","getPathInfo","colon","pathEnv","cwd","PATH","pathExtExe","unshift","which","found","step","all","ppRaw","pathPart","pCmd","subStep","ii","ext","then","res","j","cur","nothrow","pathKey","environment","reverse","resolveCommandAttempt","parsed","withoutPathExt","hasCustomCwd","shouldSwitchCwd","chdir","disabled","resolved","command","getPathKey","delimiter","metaCharsRegExp","arg","doubleEscapeMetaChars","alloc","fd","openSync","readSync","closeSync","string","shebangRegex","argument","binary","shebangCommand","isWin","isExecutableRegExp","isCmdShimRegExp","parseNonShell","commandFile","resolveCommand","shebang","readShebang","detectShebang","needsShell","forceShell","needsDoubleEscapeMetaChars","shellCommand","comspec","windowsVerbatimArguments","original","shell","notFoundError","syscall","errno","spawnargs","verifyENOENT","status","hookChildProcess","cp","originalEmit","arg1","verifyENOENTSync","spawn","parse","spawned","enoent","spawnSync","ServerProcessError","[object Object]","cause","super","State","ServerProcessManager","STOPPED","INITIALIZING","READY","portPromise","config","startup","javaProcess","removeListeners","kill","jvmArguments","schemaCacheSize","javaExecutablePath","waitForPort","setDefaultListeners","shutdown","stdout","stderr","wildcardFlags","none","localparts","validationMessageRegex","subscriptions","CompositeDisposable","serverProcessManager","ensurePort","buildValidationRequestHeaders","responseLine","exec","getRawValidationMessage","suggestionOptions","autocompleteScope","getSchemaForSuggestions","wildcardSuggestions","buildAutocompleteRequestHeaders","isStopped","getPortIfStartupTriggered","getPortIfReadyNow","configRules","allRules","packageRules","matchingRule","grammarScopes","defaultParserConfig","autocompletePriority","rnc","rng","xsd","handlePackageChanges","newGrammarScopes","grammars","getGrammars","grammar","scopeName","getActivePackages","setPackageRules","cancelNextAutocomplete","require","install","add","observe","addWarning","setConfigRules","setJvmArguments","setJavaExecutablePath","setSchemaCacheSize","commands","linter-autocomplete-jing:clear-schema-cache","clearSchemaCache","setPackageChangeListeners","onDidActivatePackage","onDidDeactivatePackage","hasActivatedInitialPackages","onDidActivateInitialPackages","dispose","selector","disableForSelector","inclusionPriority","excludeLowerPriority","dispatch","views","getView","suggestion","setTimeout","activatedManually","triggerAutocomplete","lintsOnChange","requestValidation","validate"],"mappings":"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"}